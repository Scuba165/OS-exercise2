Λειτουργικά Συστήµατα (K22) / Περίοδος 2023-2024
2η Εργασία
Ονοματεπώνυμο: Παπαδόπουλος Χρήστος ΑΜ: 1115202000165

• Παραδοτέα
    Παραδίδονται όλα τα ζητούμενα της εργασίας. Κατά την εκτέλεση του usertests περνάνε επιτυχώς όλα τα tests 
    που δημιουργούνται.

• usys.pl, syscall.h, syscall.c 
    Έγινε απλώς προσθήκη των δύο επιπλέον κλήσεων συστήματος, όπως είναι καταχωρημένες και οι προηγούμενες. 

• sysproc.c
    Υλοποιήθηκαν οι δύο απλές κλήσεις sys_setpriority, sys_getpinfo που περνάνε τα ορίσματα από user σε kernel 
    level για να κληθούν οι συναρτήσεις.

• proc.h
    Προστέθηκε στη δομή proc μία επιπλέον μεταβλητή priority η οποία αναπαριστά την προτεραιότητα της διεργασίας,
    όπως αυτή περιγράφεται και στην εκφώνηση. Ορίστηκε επίσης η δομή pstat, η οποία αποτελείται από πίνακες για κάθε 
    πεδίο της δομής proc που θέλουμε να χρησιμοποιήσουμε στην κλήση συστήματος ps και τη μεταβλητή usedProcs, η οποία
    δείχνει πόσες διεργασίες είναι ενεργές ώστε να γνωρίζουμε πόσες θέσεις των πινάκων χρησιμοποιούνται. Το πεδίο του 
    ονόματος της διεργασίας έχει προκαθορισμένο μέγεθος 16 χαρακτήρων, όπως είναι υλοποιημένο και στη δομή proc. Ορίστηκαν 
    επιπλέον και οι συναρτήσεις setpriority, getpinfo.

• proc.c
    Για αρχή, στην procinit(), αρχικοποιούμε το priority σε 10(default priority βάσει εκφώνησης).

    Για την int setpriority(int priority) χρησιμοποιούμε τη συνάρτηση myproc() όπου δίνει στη μεταβλητή p την 
    διέυθυνση της διεργασίας που κάλεσε την κλήση συστήματος. Στη συνέχεια, πραγματοποιούμε έλεγο ότι η προτεραιότητα
    που έχει δοθεί είναι μέσα στο επιτρεπτό διάστημα([1,20]). Αν είναι επιστρέφουμε -1 ως λανθασμένη εκτέλεση. Εάν είναι
    στο επιτρεπτό διάστημα, θέτουμε το πεδίο p->priority ίσο με τη δωσμένη προτεραιότητα και επιστρέφουμε επιτυχία(0).

    Για την int getpinfo(struct pstat* pstat) απαιτείται να χρησιμοποιήσουμε μία προσωρινή δομή temp_pstat στην οποία θα 
    κρατήσουμε αρχικά τα δεδομένα των διεργασιών. Διασχίζουμε τον πίνακα των διεργασιών και για κάθε μία, αν είναι ενεργή(δηλαδή 
    αν δεν είναι UNUSED), στη θέση pos των πινάκων του temp_pstat κρατάμε τα πεδία που μας ενδιαφέρουν. Για το όνομα απαιτείται η 
    χρήση της συνάρτηση safestrcpy ώστε να μεταφερθεί σωστά. Για κάθε μεταβλητή που περνάμε στη δομή, αυξάνουμε το pos, το οποίο
    στο τέλος του πίνακα εκφράζει το πλήθος των ενεργών διεργασιών, οπότε το κρατάμε και αυτό στο πεδίο usedProcs της pstat. 
    Επαναφέρουμε τη μεταβλητή p που χρησιμοποιήθηκε για τον έλεγχο όλων των διεργασιών στην διεργασία που έκανε την κλήση μέσω 
    της συνάρτησης myproc(). Χρησιμοποιούμε τη συνάρτηση copyout με όρισμα το pagetable της διεργασίας που έκανε την κλήση,
    προορισμό τη διεύθυνση του pstat στο user level και αρχική διεύθυνση την προσωρινή δομή που ορίσαμε μέσα στην συνάρτηση η 
    οποία βρίσκεται στο kernel level, με μέγεθος για την αντιγραφή ίσο με το μέγεθος της δομής pstat. Αφού ελέγξουμε ότι η 
    αντιγραφεί γίνεται με επιτυχία επιστρέφουμε 0, ενώ αν υπάρξει κάποιο σφάλμα στην αντιγραφή επιστρέφουμε -1 για αποτυχημένη 
    εκτέλεση.

    Για τον priority scheduler σε κάθε επανάληψη αρχικοποιούμε μία μεταβλητή minPrio = 21 η οποία εκφράζει την υψηλότερη
    προτεραιότητα που έχουμε βρει. Κάθε φορά που μία διεργασία είναι RUNNABLE και έχει υψηλότερη προτεραιότητα, ενημερώνουμε 
    τη minPrio με την νέα τιμή και κρατάμε τη διεργασία αυτή στη μεταβλητή struct proc *nextProc. Στο τέλος του loop του πίνακα
    των διεργασιών, ελέγχουμε ξανά ότι έχουμε βρει διεργασία, και αφού είναι ακόμα RUNNABLE, κάνουμε aqcuire το lock, την
    αλλάζουμε σε RUNNING και την εκτελούμε. Κάνουμε release το lock και είμαστε έτοιμη για να βρούμε την επόμενη διεργασία με 
    τον ίδιο τρόπο. 
    
